## LLM“记忆”模式

### 探讨与人脑记忆模式的不同

1. 记忆的存储方式
   * **LLM**：LLM通过大量的文本数据进行训练，并将这些数据转化为权重（weights），存储在神经网络中。这些权重实际上不是像人类记忆那样明确的“记忆片段”，而是对语言模式的统计理解。模型通过权重调整，预测下一个词或生成合理的句子。
   * 人脑🧠：人类的大脑记忆被认为是分散在大脑的不同区域中，像海马体（hippocampus）这样的结构在形成和检索记忆中起关键作用。大脑通过神经突触连接的强弱来调整信息的存储。大脑的记忆不仅仅是对数据的“统计归纳”，还包含了情感、经验、直觉等复杂信息。
2. 记忆的检索方式
   * **LLM**：LLM在“生成”内容时，本质上是在通过输入的提示词从其“权重空间”中寻找与之相关的语言模式。这是通过深度学习中的矩阵操作来实现的。LLM的输出可以说是“基于上下文的统计生成”，而非固定的记忆片段。
   * **人脑🧠**：人类记忆的检索常常与情景相关，某个特定的经历可能会触发许多相关的记忆，而且记忆会逐渐演变并受到新的信息影响。人脑记忆的检索还依赖于大脑的执行功能，能够基于过去的经验灵活应对新情况。
3. 记忆的可塑性
   * **LLM**：模型的“记忆”是固定的，一旦模型训练完成，其权重不再变化（除非进行微调或再训练）。这意味着它的“记忆”是基于训练时的数据集，不会在生成过程中学习新的信息
   * **人脑🧠**：大脑的可塑性非常强，可以随着新的经历和学习不断调整和重组神经连接。人类可以通过不断学习和适应来更新和调整他们的记忆。这种持续的学习能力是大脑与LLM的一大区别。
4. 记忆的组织形式
   * **LLM**：LLM的“记忆”是通过参数来编码的，权重之间的关系反映了它对语言模式的理解，但它并没有明确的“知识库”或“事件时间线”。它生成内容时不会参考某个明确的过去“记忆”，而是通过已学到的模式。
   * **人脑🧠**：人类的记忆是有一定的结构化的，包含了对时间线、空间感、事件顺序等的感知。我们可以通过回忆事件的顺序、场景和相关人物来重建过去的记忆。
5. 忘记与记忆
   * **LLM**：LLM不会“忘记”任何东西，除非模型被重新训练或微调。它在训练过程中对所有数据进行无差别的吸收，而不会像人类那样有选择性地遗忘或忽略不重要的信息。
   * **人脑🧠**：人类的记忆是有限的，而且具有选择性遗忘的功能。大脑会筛选掉一些不重要的或长期不用的记忆，以节省资源。人类的遗忘有时也是一种适应机制，帮助我们专注于当前的重要任务。

总结：LLM没有真正的“记忆”和“感知”，更多是对数据的统计建模，而人类的记忆则是高度动态、情景化并与情感相连的。

### 提高LLM的记忆能力

#### :dart:微调(针对下游任务全参微调)

微调过程虽然增强了模型的记忆能力，但因为是对全局权重的调整，往往需要耗费大量资源，且不够灵活。如果过度微调，模型可能会出现“灾难性遗忘”（Catastrophic Forgetting），即新知识的引入会导致模型遗忘先前的信息。

#### :dart:只微调最后几层 --- 实现短期记忆

1. 持续微调：

   * 定期用新的数据集或任务来微调最后一两层。例如，在处理流式数据或实时数据时，可以频繁地用新数据更新这些层的权重。
   * 可以使用 **学习率调度** 来控制每次微调的更新幅度，确保模型在适应新信息时不会过度偏移。

2. 更新权重的过程

   * 首先，你需要收集用户的输入(用户：今天称重45kg)并将其存储为模型的训练数据：

     ```python
     user_input = "今天称重 XX kg" # 提取出重要/个性化信息，将这些信息mask掉
     ```

   * 预处理输入：接下来，对用户输入进行预处理以生成模型所需的输入格式。这可能包括分词、编码等。

   * 定义标签：如果目标是让模型记住特定信息，可以将其设置为编码后的输出。

     ```python
     label = "今天称重45kg" 
     encoded_label = tokenizer(label, return_tensors='pt')
     ```

#### :dart:外部存储

外部存储：为模型引入外部内存系统（short RAG） 允许内存动态读写记忆

模型可以在生成过程中保留短期信息

并通过访问外部存储来调取最近的记忆



问题如下：

1. 要train一个gating能够分辨信息是短期记忆、中期记忆和长期记忆这件事本身并不容易。要不就直接阐述gating的背后就agent

   还有一种方法：当它发现要存短期的时候，发现存取的值跟原来的值之前的相关性很强（这里的相关性的值我们可以设置一个阈值），当超过这个阈值的时候，需要启动中期记忆

2. 既然你都是去接一个外部的数据库去存，为什么一定要分成这三个存储不同记忆信息的rag？